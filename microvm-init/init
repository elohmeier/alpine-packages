#!/bin/busybox sh
set -e

PATH=/usr/bin:/usr/sbin:/sbin:/bin

# Default is 777 which creates problems
chmod 0755 /

mount -t proc proc -o nodev,nosuid,hidepid=2 /proc
# Fetch settings from cmdline
DNS="$(tr ' ' '\n' < /proc/cmdline | grep "dns=" | cut -d'=' -f2-)"
HOSTNAME="$(tr ' ' '\n' < /proc/cmdline | grep "hostname=" | cut -d'=' -f2-)"
SSHKEY="$(tr ' ' '\n' < /proc/cmdline | grep "sshkey=" | cut -d'=' -f2- | base64 -d)"

# TODO(mattmoor): Check for debug logging and enable "set -x"

mount -t devtmpfs -o nosuid,noexec devtmpfs /dev
mount -t sysfs sys -o nodev,nosuid,noexec /sys
mount -t tmpfs tmpfs /tmp
mkdir -p -m 0755 /dev/shm
mount -t tmpfs -o mode=1777 tmpfs /dev/shm

# Setup tty/pty
mkdir /dev/pts
mount -t devpts devpts -o noexec,nosuid,newinstance,ptmxmode=0666,mode=0620,gid=tty /dev/pts/
mount --bind /dev/pts/ptmx /dev/ptmx

# Fix /dev/fd
ln -s /proc/kcore /dev/core
ln -s /proc/self/fd /dev/fd
ln -s /proc/self/fd/0 /dev/stdin
ln -s /proc/self/fd/1 /dev/stdout
ln -s /proc/self/fd/2 /dev/stderr

if [ -z "${SSHKEY}" ]; then
	echo "Missing default mount for ssh keys"
	exit 1
fi

# We can ignore this fail, if we use a kernel with kvm_guest.config, we won't need this
# and network will work anyway
# If this fails and we won't have network, the ifconfig command will fail anyway.
# Also we load cpu acceleration drivers in case those are needed.
[ -e "/lib/modules/$(uname -r)/" ] && depmod -a
sort -u /sys/devices/system/cpu/modalias 2>/dev/null | xargs -n1 modprobe 2>/dev/null || :
sort -u /sys/devices/pci*/*/virtio*/modalias 2>/dev/null | xargs -n1 modprobe 2>/dev/null || :
# modprobe 9p if absent
if ! grep -q 9p /proc/filesystems; then
	modprobe virtio 2>/dev/null || :
	modprobe virtio_blk 2>/dev/null || :
	modprobe virtio_gpu 2>/dev/null || :
	modprobe virtio_net 2>/dev/null || :
	modprobe virtio_pci 2>/dev/null || :
	modprobe virtio_pci_legacy_dev 2>/dev/null || :
	modprobe virtio_pci_modern_dev 2>/dev/null || :
	modprobe virtio_pmem 2>/dev/null || :
	modprobe virtio_ring 2>/dev/null || :
	modprobe virtio_rng 2>/dev/null || :
	modprobe virtio_scsi 2>/dev/null || :
	modprobe 9pnet_virtio 2>/dev/null || :
	modprobe 9pnet 2>/dev/null || :
	modprobe 9p 2>/dev/null || :
fi

# If we have an external disk, we want to perform builds in that
if [ -e /dev/vda ]; then
	grep -q xfs /proc/filesystems || modprobe xfs
	mkfs.xfs \
		-f \
		-b size=4096 \
		-s size=4096 \
		-d agcount=8 \
		-i size=512 \
		-l size=64m,lazy-count=1 \
		/dev/vda
	mkdir -p /mount
	mount -o noatime,nodiratime,logbufs=8,logbsize=256k -t xfs /dev/vda /mount
	# Extract build environment in /mount
	tar --xattrs --xattrs-include='*' -xpf /dev/vdb -m -k --ignore-zeros --record-size=64K --numeric-owner -C /mount/
	mkdir -p /mount/mnt
	# ensure permissions are correct for sshd's ChrootDirectory
	chown root:root /mount
	chmod 0755 /mount

	# Ensure mount points exist for bind mounts
	mkdir -p /mount/dev /mount/proc /mount/sys /mount/tmp /mount/run
	# Ensure /var/tmp exists (needed by podman)
	mkdir -p -m 1777 /mount/var/tmp

	# Ensure root user exists in guest passwd/group for chrooted SSH
	if [ -f /mount/etc/passwd ] && ! grep -q "^root:" /mount/etc/passwd; then
		echo "root:x:0:0:root:/root:/bin/sh" >> /mount/etc/passwd
	fi
	if [ -f /mount/etc/group ] && ! grep -q "^root:" /mount/etc/group; then
		echo "root:x:0:root" >> /mount/etc/group
	fi
	# Ensure sshd user exists in guest for privilege separation
	if [ -f /mount/etc/passwd ] && ! grep -q "^sshd:" /mount/etc/passwd; then
		echo "sshd:x:22:22:sshd:/var/empty:/sbin/nologin" >> /mount/etc/passwd
	fi
	if [ -f /mount/etc/group ] && ! grep -q "^sshd:" /mount/etc/group; then
		echo "sshd:x:22:" >> /mount/etc/group
	fi
	mkdir -p /mount/var/empty
	chmod 0755 /mount/var/empty
	mkdir -p /mount/root/.ssh
	chmod 0700 /mount/root/.ssh
	echo "${SSHKEY}" > /mount/root/.ssh/authorized_keys
	chmod 0400 /mount/root/.ssh/authorized_keys

	# Make /home/build world writeable under /mount
	chmod 0777 /mount/home/build
fi

# Setup default mountpoint for 9p shared dir
mount -t 9p \
	-o trans=virtio \
	-o version=9p2000.L \
	-o security_model=mapped-xattr \
	-o posixacl=on \
	-o msize=104857600 \
	defaultshare /mount/mnt/

# Allow the user we are running as to copy things to the shared dir
chmod 0777 /mount/mnt

mount --rbind /dev /mount/dev
mount --rbind /proc /mount/proc
mount --rbind /sys /mount/sys
mount --rbind /tmp /mount/tmp
mount -t tmpfs -o mode=1777 tmpfs /mount/run

mount -t cgroup2 -o nsdelegate,memory_recursiveprot,nosuid,nodev,noexec cgroup2 /mount/sys/fs/cgroup || :
mkdir -p /mount/dev/pts
mount -t devpts devpts -o noexec,nosuid,newinstance,ptmxmode=0666,mode=0620,gid=tty /mount/dev/pts/
mount --bind /mount/dev/pts/ptmx /mount/dev/ptmx
# Tell software that we're acting more like a container than a full VM
touch /mount/.dockerenv

#########################
# OPENRC INITIALIZATION #
#########################

# Initialize OpenRC environment if openrc is installed in the guest
if [ -x /mount/sbin/openrc ] || [ -d /mount/etc/init.d ]; then
	echo "[INIT] Initializing OpenRC environment..." > /dev/console

	# Create OpenRC runtime directories
	mkdir -p /mount/run/openrc/started /mount/run/openrc/starting /mount/run/openrc/inactive
	touch /mount/run/openrc/softlevel

	# Configure OpenRC for container/VM environment
	cat > /mount/etc/rc.conf << 'EOF'
rc_sys="docker"
rc_controller_cgroups="YES"
rc_depend_strict="NO"
rc_provide="loopback net"
EOF

	# Ensure fstab exists
	touch /mount/etc/fstab

	# Setup network interfaces config
	mkdir -p /mount/etc/network
	cat > /mount/etc/network/interfaces << 'EOF'
auto lo
iface lo inet loopback
EOF

	# Ensure runlevels directory exists
	mkdir -p /mount/etc/runlevels/default

	# Mark required services as "started" so dependencies are satisfied
	for svc in cgroups net networking localmount hostname loopback; do
		touch /mount/run/openrc/started/$svc
	done

	echo "[INIT] OpenRC environment initialized" > /dev/console
fi

# Set default hard limit of open file descriptors to match systemd init
# behavior. The pam_limit module uses the settings in /proc/1/limit as
# its default values.
if [ -f /proc/sys/fs/nr_open ] ; then
	nofile_limit=$(ulimit -H -n)
	kernel_max_limit=$(cat /proc/sys/fs/nr_open)
	# ensure that we are increasing the hard limit
	if echo "${kernel_max_limit}" | grep -qE '^[0-9]+$' &&
		[ "${nofile_limit}" -lt "${kernel_max_limit}" ] ; then

		ulimit -H -n "$kernel_max_limit"
	fi
fi

# ldconfig is run to prime ld.so.cache for glibc packages which require it.
chroot /mount /bin/sh -c "[ -x /sbin/ldconfig ] && /sbin/ldconfig /lib /usr/lib /usr/lib64" || :

# Setup default network
interface_name="$(ip -o link show | grep 'BROADCAST,MULTICAST' | head -n 1 | cut -d':' -f2 | tr -d ' ')"
ip link set lo up
ip link set "${interface_name:-"eth0"}" up
ip addr add 10.0.2.15/24 dev "${interface_name:-"eth0"}"
ip route add default via 10.0.2.2 dev "${interface_name:-"eth0"}"

hostname "${HOSTNAME:-"alpine-vm"}"
echo "${HOSTNAME:-"alpine-vm"}" > /mount/etc/hostname
echo "127.0.0.1 ${HOSTNAME:-"alpine-vm"}" >> /mount/etc/hosts
rm -f /mount/etc/resolv.conf
echo "nameserver ${DNS:-"10.0.2.3"}" > /mount/etc/resolv.conf

#########################
# INIT.D SCRIPT RUNNER  #
#########################

echo "[INIT] Checking for init.d scripts..." > /dev/console

# Run scripts from /opt/melange/init.d/ in numeric order
# Scripts are executed (run in separate process) and must succeed (set -e)
if [ -d /opt/melange/init.d ]; then
	for script in /opt/melange/init.d/*; do
		if [ -f "$script" ] && [ -x "$script" ]; then
			echo "[INIT] Executing init.d script: $(basename $script)" > /dev/console
			# Execute the script - runs in separate process
			# Will halt on error due to 'set -e' at top of this script
			"$script"
			echo "[INIT] Completed: $(basename $script)" > /dev/console
		fi
	done
	echo "[INIT] All init.d scripts completed successfully" > /dev/console
else
	echo "[INIT] No /opt/melange/init.d directory (optional, skipping)" > /dev/console
fi

##############
# Entrypoint #
##############
# Setup SSH keys for external access
mkdir -p -m 0700 /root/.ssh/
echo "${SSHKEY}" > /root/.ssh/authorized_keys
chmod 0400 /root/.ssh/authorized_keys

# Setup base passwd/group with root user
echo "root:x:0:0:root:/root:/bin/sh" > /etc/passwd
echo "root:x:0:root" > /etc/group

# Copy the user/group files from the guest filesystem to the host
# and make sure that all the users that have /bin/sh as their shell
# have their home directory created and the ssh key copied there.
if [ -f /mount/etc/passwd ]; then
	# Append guest users (skip root if it exists)
	grep -v "^root:" /mount/etc/passwd >> /etc/passwd 2>/dev/null || :
fi
if [ -f /mount/etc/group ]; then
	grep -v "^root:" /mount/etc/group >> /etc/group 2>/dev/null || :
fi

# Ensure sshd user exists for privilege separation
if ! grep -q "^sshd:" /etc/passwd; then
	echo "sshd:x:22:22:sshd:/var/empty:/sbin/nologin" >> /etc/passwd
fi
if ! grep -q "^sshd:" /etc/group; then
	echo "sshd:x:22:" >> /etc/group
fi
mkdir -p /var/empty
chmod 0755 /var/empty

for i in $(awk -F: '$7 == "/bin/sh" {print $1}' /etc/passwd); do
	home="$(grep "^$i:" /etc/passwd | cut -d':' -f6)"
	group="$(grep "^$i:" /etc/passwd | cut -d':' -f4)"
	mkdir -p "$home/.ssh"
	echo "${SSHKEY}" > "$home/.ssh/authorized_keys"
	chmod 0400 "$home/.ssh/authorized_keys"
	chown -R "$i":"$group" "$home"
done

# Generate host keys if they don't exist (they should be injected by melange)
if [ ! -f /etc/ssh/ssh_host_ed25519_key ]; then
	ssh-keygen -A -a 1
fi
exec /usr/sbin/sshd -D -e
